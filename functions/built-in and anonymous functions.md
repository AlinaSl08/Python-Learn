✅ **Встроенная функция `map(func, iterable, *iterables)`** возвращает итератор с результатами применения функции `func` к элементам итерируемого объекта `iterable`. Если передано несколько итерируемых объектов, в функцию `func` будут передаваться сразу несколько элементов, расположенных на одинаковых позициях.

✅ **Встроенная функция `filter(func, iterable)`** возвращает итератор, содержащий только те элементы итерируемого объекта `iterable`, для которых функция `func` возвращает `True`. Если вместо `func` указать `None`, каждый элемент будет проверен на соответствие значению `True`.

✅ **Функция `reduce(func, iterable, initializer=None)`** из модуля `functools` последовательно применяет функцию `func` к элементам итерируемого объекта `iterable` слева направо, сводя его к одному значению. Начальное значение задаётся через `initializer`. Если начальное значение не установлено, то в его качестве используется первое значение `iterable`.

✅ **Итераторы** – важная концепция языка Python. Нужно помнить:

+ итераторы можно обойти циклом `for`;
+ итератор можно преобразовать в список или кортеж, с помощью функций `list()` и `tuple()`;
+ итератор можно распаковать с помощью `*`.

✅ Список некоторых функций из **модуля `operator`**:

|Операция|	Синтаксис|	Функция|
|:--:|:--:|:--:|
|Addition|	`a + b`|	`add(a, b)`|
|Containment Test|	`obj in seq`|	`contains(seq, obj)`|
|Division|	`a / b`|	`truediv(a, b)`|
|Division|	`a // b`|	`floordiv(a, b)`|
|Exponentiation|	`a ** b`|	`pow(a, b)`|
|Modulo|	`a % b`|	`mod(a, b)`|
|Multiplication|	`a * b`|	`mul(a, b)`|
|Negation (Arithmetic)|	`-a`|	`neg(a)`|
|Subtraction|	`a - b`|	`sub(a, b)`|
|Ordering|	`a < b`|	`lt(a, b)`|
|Ordering|	`a <= b`|	`le(a, b)`|
|Equality|	`a == b`|	`eq(a, b)`|
|Difference|	`a != b`|	`ne(a, b)`|
|Ordering|	`a >= b`|	`ge(a, b)`|
|Ordering|	`a > b`|	`gt(a, b)`|

✅ **Встроенная функция `all(iterable)`** возвращает значение `True`, если **все элементы** переданной ей последовательности (итерируемого объекта) истинны (приводятся к значению `True`), или `False` в противном случае. Обратите внимание: если переданный итерируемый объект пустой, то функция `all()` возвращает значение `True`.

✅ **Встроенная функция `any(iterable)`** возвращает значение `True`, если **хотя бы один элемент** переданной ей последовательности (итерируемого объекта) является истинным (приводится к значению `True`), или `False` в противном случае. Обратите внимание: если переданный объект пуст, то функция `any()` возвращает значение `False`.

✅ **Встроенная функция `enumerate(iterable, start)`** возвращает кортеж из индекса элемента и самого элемента переданной ей последовательности (итерируемого объекта). С помощью необязательного параметра `start` можно задать начальное значение индекса. По умолчанию значение параметра `start = 0`, то есть счет начинается с нуля.

✅ **Встроенная функция `zip(*iterables)`** объединяет отдельные элементы из каждой переданной ей последовательности (итерируемого объекта) в кортежи. Если функции `zip()` передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину.

# Анонимные функции

✅ **Анонимные функции (лямбда-функции)** – это короткие однострочные функции с использованием **оператора lambda**.

✅ **Общий формат** определения анонимной функции: 

``` python
lambda список_параметров: выражение,
```
где `список_параметров` – список параметров через запятую, `выражение` – значение, либо код, дающий значение.

✅ Когда применение анонимных функций оправдано:

+ однократное использование функции;
+ передача функций в качестве аргументов другим функциям;
+ возвращение функции в качестве результата другой функции.

✅ В теле анонимной функции можно использовать **тернарный условный оператор**:

``` python
значение1 if условие else значение2
```
Если `условие` истинно, возвращается `значение1` , если нет – `значение2`.

✅ Анонимные функции поддерживают все способы передачи аргументов:

+ позиционные аргументы;
+ именованные аргументы;
+ переменный список позиционных аргументов (`*args`);
+ переменный список именованных аргументов (`**kwargs`);
+ обязательные аргументы (`*`).
  
✅ **Особенности и ограничения** анонимных функций в Python:

+ анонимная функция может содержать только выражение, и не может включать в свое тело операторы;
+ в теле анонимной функции такие операторы, как `return`, `pass`, `assert` или `raise`, вызовут исключение `SyntaxError`;
+ анонимная функция пишется как одна строка исполнения;
+ анонимная функция может быть немедленно вызвана.
